package discord

import (
	"encoding/json"
	"fmt"
	"time"
)

// Payload is a simple structure used to receive and send events over the websocket
type Payload struct {
	OPCode   int             `json:"op"`
	Data     json.RawMessage `json:"d"`
	Sequence int             `json:"s,omitempty"`
	Event    string          `json:"t,omitempty"`
}

// Heartbeat is the type used to send a heartbeat back over the Discord websocket
type Heartbeat struct {
	OPCode int `json:"op"`
	Data   int `json:"d"`
}

// Timestamp stores a timestamp, as sent by the Discord API.
type Timestamp string

// Parse parses a timestamp string into a time.Time object.
// The only time this can fail is if Discord changes their timestamp format.
func (t Timestamp) Parse() (time.Time, error) {
	return time.Parse(time.RFC3339, string(t))
}

// Message is Discord's message structure
type Message struct {
	ID              string      `json:"id,omitempty"`               // id of the message
	ChannelID       string      `json:"channel_id,omitempty"`       // id of the channel the message was sent in
	GuildID         string      `json:"guild_id,omitempty"`         // (?) id of the guild the message was sent in
	Content         string      `json:"content,omitempty"`          // contents of the message
	SentAt          Timestamp   `json:"timestamp,omitempty"`        // ISO8601 timestamp when this message was sent
	EditedAt        Timestamp   `json:"edited_timestamp,omitempty"` // (?) ISO8601 timestamp when this message was edited (or null if never)
	TTS             bool        `json:"tts,omitempty"`              // boolean whether this was a TTS message
	MentionEveryone bool        `json:"mention_everyone,omitempty"` // boolean whether this message mentions everyone
	MentionedRoles  []string    `json:"mention_roles,omitempty"`    // array of role object ids - roles specifically mentioned in this message
	Pinned          bool        `json:"pinned,omitempty"`           // boolean whether this message is pinned
	WebhookID       string      `json:"webhook_id,omitempty"`       // (?) snowflake if the message is generated by a webhook, this is the webhook's id
	Type            int         `json:"type,omitempty"`             // integer type of message
	Embed           interface{} `json:"embed,omitempty"`            // array of embed objects any embedded content

	// Values yet to be implemented as they are not yet needed

	// Activity        []Activity    `json:"activity,omitempty"`         // (?) message activity object sent with Rich Presence-related chat embeds
	// Application     []Application `json:"application,omitempty"`      // (?) message application object sent with Rich Presence-related chat embeds
	// Author          User          `json:"author,omitempty"`           //* user object the author of this message (not guaranteed to be a valid user, see below)
	// Member          GuildMember   `json:"member,omitempty"`           // (?) partial guild member object member properties for this message's author
	// Attachments     []Attachment  `json:"attachments,omitempty"`      // array of attachment objects any attached files
	// Reactions       []Reaction    `json:"reactions,omitempty"`        // (?) array of reaction objects reactions to the message
	// Nonce           string        `json:"nonce,omitempty"`            // (?) snowflake used for validating a message was sent
	// Mentions        []User        `json:"mentions,omitempty"`         // array of user objects, with an additional partial member field users specifically mentioned in the message
}

// APIPayload is a payload for sending a text based message over Discord's API
type APIPayload struct {
	APIURL  string
	Payload []byte
}

// Prepare is a helper command for formatting the message to an APIPayload type
func (p *APIPayload) Prepare(content, channel string) error {
	payload := Message{Content: content}
	byteArray, err := json.Marshal(payload)
	if err != nil {
		return err
	}
	p.Payload = byteArray
	p.APIURL = fmt.Sprintf("/channels/%v/messages", channel)
	return nil
}

// APIEmbedPayload is a payload for sending an embed based message over Discord's API
type APIEmbedPayload struct {
	APIURL  string
	Payload []byte
}

// Prepare is a helper command for formatting the message to an APIEmbedPayload type
func (p *APIEmbedPayload) Prepare(embed map[string]interface{}, channel string) error {
	payload := Message{Embed: embed}
	byteArray, err := json.Marshal(payload)
	if err != nil {
		panic(err)
		return err
	}
	p.Payload = byteArray
	p.APIURL = fmt.Sprintf("/channels/%v/messages", channel)
	return nil
}
